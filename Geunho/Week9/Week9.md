### 백트래킹

#### 백트래킹과 백트래킹 알고리즘 개념

깊이 우선 탐색, 너비 우선 탐색은 데이터를 전부 확인하는 방법이며 이를 완전 탐색이라고 함  
완전 탐색은 모든 경우의 수를 탐색하는 방법이므로 비효율적  
따라서 탐색을 하다가 가능성이 없다면 되돌아가고, 가능성이 있는 곳을 탐색하는 알고리즘을 백트래킹이라고 한다

백트래킹 알고리즘의 핵심은 '해가 될 가능성을 판단하는 것'이며 그것을 유망함수라는 것을 정의하여 판단함

1. 유효한 해의 집합을 정의
2. 위 단계에서 정의한 집합을 그래프로 표현
3. 유망 함수를 정의
4. 백트래킹 알고리즘을 활용해서 해를 찾음

예를 들어 1, 2, 3, 4 중 2개의 숫자를 뽑아서 6보다 큰 조합을 찾을 때 백트래킹을 활용한다면  
유망 함수로는 처음 숫자가 3 미만이면 백트래킹한다라는 전략으로 접근 가능  
또는 부분 집합의 합이 K가 되는 경우를 구할 때 완전 탐색은 포함/미포함 경우의 수로 봤을 때 2^n 이지만  
백트래킹을 활용한다면 1) 합이 K가 되면 더 탐색하지 않고 2) 현재까지의 합이 K 이상이라면 더 탐색하지 않을 수 있음

### 몸풀기 문제

#### 1부터 N까지 숫자 중 합이 10이 되는 조합 구하기

유망 함수의 조건

1. 합이 10이 되는 경우 바로 return 및 결과에 추가
2. 숫자의 합이 10보다 크면 백트래킹

0부터 시작해서 제일 하단의 backtrack은 아래와 같이 퍼지는 형태. 즉 유효한 해의 집합을 구성하는 코드 연습이 필요함 
```python
# [1] -> [1, 2]
#        [1, 3]
#        [1, 4]
#        ...
#        [1, N]
# [2] -> [2, 3]
#     -> [2, 4]
#     -> [2, 5]
#        ...
# [3] -> [3, 4]
#        ...
# ...
# [7] -> [7, 8]
#        ...
```

```python
from typing import List


def solution(N: int) -> List[List[int]]:
    results = []

    def backtrack(total_sum: int, path: List[int], start: int):
        if total_sum == 10:
            results.append(path)
            return

        for i in range(start, N + 1):
            if total_sum + i <= 10:
                backtrack(total_sum + i, path + [i], i + 1)

    backtrack(0, [], 1)
    return results


assert solution(5) == [[1, 2, 3, 4], [1, 4, 5], [2, 3, 5]]
assert solution(2) == []
assert solution(7) == [
    [1, 2, 3, 4],
    [1, 2, 7],
    [1, 3, 6],
    [1, 4, 5],
    [2, 3, 5],
    [3, 7],
    [4, 6],
]
```

### 실전 문제
